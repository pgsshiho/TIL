# 알고리즘
프로그램의 구성요소,**문제에 답을 찾아내는 방법**
## 정의
프로그램작성 과정 중 **설계/계획에 포함**, 문제 해결을 위한 일련의 절차나 방법을 공식화한 형태 또는 계산을 실행하기 위한 **단계적 절차**
## 5가지 특성
1. 입력:입력되는 값은 **0개 이상**이어야 한다.
2. 출력: 출력되는 결과가 **1개 이상**이어야 한다.
3. 명확성: 각 명령어의 **의미가 명확**해야 한다.
4. 유한성: 정해진 단계를 지나면 **종료되어야** 한다.
5. 유효성: 모든 명령을 **실행가능한 연산**이어야 한다.
# 프로그래밍 언어
## 개요
프로그래밍 언어란 컴퓨터 시스템을 동작시키기 위한 **프로그램 작성언어**를 말한다  
프로그램은 다소 단순해 보이는 명령어 들의 조합으로 구성되는데, 이러한 조합들을 비트라고 불리는 0과1의 값으로 작성되거나 변환되어 **컴퓨터가 이해할 수 있도록** 한다 
## Bit
컴퓨터가 이해하기 위한 가장 기본적인 용어로,BinaryDigit의 약칭
1Byte == 8bit, 1kilobyte == 8192bit,이후는 2^10씩 byte가 늘어난다
## 컴퓨터 시스템의 구조
컴퓨터는 전달받은 0과 1의 값들을 정해진 순서대로 실행하며 그 과정에서 처리,저장등을 수행,**프로그램 실행 및 데이터 처리는 중앙처리장치(CPU)에서 수행,저장은 기억장치(Memory)에서 수행 cpu로 부터 명령받아 데이터를 입력 또는 출력하는 일을 입출력 장치(1/0 device)에서 수행 cpu에서는 목적에 따라 연산 등을 수행**, 연산을 위한 명령어를 실행,기록 하기 위해서는 일반적으로 **인출,해석,실행,기록**의 단계를 거쳐야 한다.
## 식별자
프로그램의 **구성요소를 구별하기 위한 기준**으로,변수명이 식별자에 속함
## 바인딩
변수가 변수에 관련된 속성을 연결하는 과정,정적,동적 바인딩으로 구분  
- 정적: 프로그램 **실행시간 전에** 속성을 연결하는 방식
- 동적: 프로그램 **실행시간에** 속성을 연셜하는 방식
## 선언
변수에 이름,데이터 타입 등의 **속성을 수여하는 작업**으로,명시적 선언과 묵시적 선언이 있다  
- 명시적: **선언문을 이용**하여 변수 이름을 나열하고 속성을 부여
- 묵시적: 별도의 **선언문 없이** 디폴트 규칙에 의해 속성을 부여
## 영역
이름이 사용되는 범위를 의미,정적,동적으로 나뉨  
- 정적: 변수를 찾을때 **구조에 기반**
- 동적: 변수를 찾을때 구조보다 **순서에 기반**
## 할당
변수에 **메모리공간을 바인딩** 하는 작업을 의미
# 자료형
## 사용자 정의 자료형
C/C++ , JAVA 와 같은 언어는 직접 **자료형을 만들수 있음**
### 열거체
괄호 안에 **연속적인 값이 들어가는 자료형**,특정 값을 넣어주지 않으면 **1씩늘어난다** 상수배열이라고 불림
```java
enum{
    black;
    red;
    yellow = 10;
    green;
};//여기서 black = 0,red = 1(0에서 1증가),yellow=10,green=11(10에서 1증가)
```
### 구조체
괄호안에 **멤버 변수를 사용하는 자료형**,내부에서 멤버 변수 자료형 선언 가능,멤버 함수 작성 가능
```java
struct test//여기서 test는 이름
{
int kor;
int eng;
int mat;
};
main()
{
    struct test t1;
    t1.kor = 90;
    t1.eng = 80;
    t1.mat = 100;
};
```
### 공용체
- 구조체와 비슷하지만 **조금더 범위가 크다** 
- 열거체와 구조체와 달리 **공용체명 작성 필요**
- **구조체를 멤버**로 사용가능
- 메모리 공간을 공유해 **크기를 작게** 사용가능
## 추상화
복잡한 문제의 본질을 이해하기 위해 세부사항은 배제하고 **중요한 부분을 중심으로 간략화**하는 기법
### 기능
입력자료를 출력자료로 **변환하는 과정을 추상화** 하는 방법
### 자료
**자료**와 자료에 적용할수있는 **오퍼레이션**을 **함께 정의**하는 방법(오퍼레이션은 추상화 할수 있게 해주는 것이다)
### 제어
**외부 이벤트**에 대한 **반응**을 **추상화** 하는 방법
## 상속
상위 수준 그룹의 **모든 특성**을 하위 수준 그룹이 이어받아 **재사용,확장** 하는 특성  
단위상속과 다중상속이 있고,상위수준의 그룹의 그룹이 하나만 존재할때 단일상속이라고 부름
## 구체화
하위 수준 그룹이 상위 수준 그룹의 **추상화 부분을 구체화** 시키는 것을 의미
# 프로그래밍 언어 특성
## 발전과정
|1960년 이전|1960년대|1970년대|1980년대|1980년 이후|
|----------|-------|---------|-------|----------|
|ASSEMBLY,FORTRAN,LISP|COBOL,PL/I,BASIC|PASCAL,C,SMALLTALK,PROLOG|ADA,C++,PYTHON,PROLOG|RUBY,JAVA,JAVASCRIPT,C#|
## 유형 분류
- 저급언어: **기계가** 이해하도록 만들어진 언어. 추상화 수준이 낮고,프로그램작성이 어려움, 기계어 어셈블리어가 속함
- 고급언어: **개발자가** 소스코드를 작성할때 쉽게 이해할 수 있도록 작성된언어 C,C++,JAVA등이 속함
### 실행 방식
- **명령형 언어**: 컴퓨터에 저장된 명령어들이 효과적으로 실행되는 프로그래밍 방식으로 **절차형 언어**
- **함수형 언어**: **수학적 수식과 같은 함수**들로 프로그램을 구상하여 호출하는 방식
- **논리형 언어**: **규칙**에 대한 활성화 **조건이 만족**되면 **연관된 규칙이 실행**되는구조,**추론과 관계 규칙**에 의해 원하는 결과를 얻음
- **객체지향 언어**: **객체간의 메세지 통신**을 이용하여 프로그래밍 하는 방식
### 구현기법
- **컴파일 방식의 언어**: **고급언어를 기계어로 번역하는 방식**의 언어를 의미. 컴파일 방식은 실행에 필여한 정보가 **컴파일시간에 계산**되어 실행 속도가 높음
- **인터프리터 방식의 언어**: 고급언어 **명령문을 하나씩 번역**하고 실행하는 방식의 언어 **프로그램실행시 계산**시작
- **혼합형 방식의 언어**: 고급 언어를 **컴파일**하여 **중간언어로 변환**후 **인터프리터**에 의해 번역을 실행
# 라이브러리
## 정의
효율적인 프로그램 개발을 위해 필요한 프로그램을 모아놓은 **집합체**  
필요할 때 찾아서 쓸수있도록 **모듈화** 되어 제공  
프로그래밍 언어에 일반적으로 **도움말,설치 파일,샘플 모드** 등을 제공
## 종류
### 표준 라이브러리
- 표준 라이브러리는 프로그래밍 언어가 **기본적으로 가지고** 있는 라이브러리를 의미가
- 각 프로그래밍 언어의 표준 라이브러리는 **여러 종류의 모듈과 패키지**를 가짐
- 표준 라이브러리를 이용하면 별도의 파일 설치없이 날짜와 시간기능을 이용가능
### 외부 라이브러리
- 외부라이브러리는 표준라이브러리와 달리 별도의 파일을 설치
- 누구나 개발,설치 가능,인터넷에 공유가능
### 모듈과 패키지
- 라이브러리는 모듈과 패키지를 총칭한다
- 개별 파일은 모듈,모듈을 모은것은 패키지 라고 한다
```
모듈:특정 기능들(변수,함수,클래스 등)이 한 개의 파일에서 기능을 제공한다  
패키지:여러 개의 모듈을 한 개의 폴더에 묶어서 기능을 제공
```
# 테스트
## 개요
- 테스트란, 개발된 응용 애플리케이션이나 시스템의 사용자가 요구하는 기능과 성능,사용성,안전성등을 확인하고 **노출되지 않은 숨어있는 결함을 찾아내는 활동**
- 테스트 과정에 필요한 역할은 **소프트웨어 아키텍트**와 **테스트 매니저**이다  
그림과 같이 두 역할은 소프트웨어 생명 주기(Life Cycle)의 V 모델에서 각각 좌측과 우측의핵심 역할을 담당하고 **서로 보완 관계**에 있다  
소프트웨어 생명 주기는 요구사할,분석,디자인,구현 또는 개발 순으로 진행되며, 프로젝트의 특성과 방법론에 따라 반복적으로 수행되기도 한다.  
테스트는 단위 테스트,통합 테스트,시스템 테스트,인수 테스트의 순으로 진행  
요구사항 -> 분석-시스템 설계 -> 디자인-모듈 설계 -> 구현-코딩 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
## 테스트의 7 원칙
1. 테스트는 **계획 단계부터** 한다
- 테스트 활동은 소프트웨어 개발 주기에서 가능한 초기부터 시작해야 한다.
2. 테스트는 **결함을 밝히**는 활동이다.
- 테스트의 목적은 결함의 제거가 아닌, 결함의 발견이다
- 테스트는 결함이 있다는 것을 보여줄 수 있지만, 결함이 없다는 것을 증명할 수는 없다
3. **완전한 테스트는 불가능**하다
- 모든 것(입력값,결로,타이밍)에 대한 테스팅은 자원의 한계로 불가능하다
4. 테스트는 **상황에 따라 다르다**
- 애플리케이션 테스트에서도 동일한 테스트에 대한 비정상적인 결함 검수가 이루어질 수 있으므로, 이러한 현상을 방지하기 위해서는 다양한 방법으로 테스트하는 것이 필요하다
5. **결함 집중을 고려**한다.
- 대부분 결함은 소수의 특정 모듈에 집중되어 발생하는 경향을 보인다.
- 결함의 80%는 20% 코드에 집중되어 있다. 즉, 결함이 높은 곳에 자원이 집중되어 있다(파레토 법칙)
6. **살충제 패러독스를 고려**한다.
- 동일한 테스트 케이스에 의한 반복적 테스트로 새로운 버그를 찾지 못하는 내성 현상을 의미
7. **오류 부재의 궤변을 고려**
- 개발한 제품이 사용자의 필요와 기대에 부응하지 못하고 쓸모가 없다면 결함을 찾는 활동은 의미가 없다.
- 개발한 제품은 요구 사항과 일치하고 사용에 적합해야 한다.
# 단위 테스트
- **작은 소프트웨어 단위**(컴포넌트 또는 모듈)를 **테스트** 하는 것으로, 일반적으로 개발자 자신에 의해 진행
- 과거에는 시간 부족을 이유로 단위 테스트가 생략되었으나 최근에는 개발 도구의 발전으로 **개발 과정중에 자동으로 진행**
- 단위 테스트는 아주 중요한 부분이므로 개발 도구에서 지원하지 않아도 **반드시 수행**
- 구조적 테스트,기능성 테스트,리소스 관련 테스트,강건성 테스트 등 특정 비기능성 테스트 등이 포함되어 수행
- 컴포넌트 명세,소프트웨어 상세 설계,데이터 모델 명세 등을 이용하여 테스트
- 방법  
화이트박스 테스트  
```
개발자 관점 구조와 동작 기반의 테스트
종류: 기초 경로 테스트,제어 흐름 테스트,조건 테스트,루프 테스트,데이터 흐름 테스트,분기 테스트
```
  
블랙박스 테스트  
```
사용자 관점,명세[요구사항과 결과물이 일치] 기반의 테스트  
종류:균등 분할(동치분해),한계값(경계값) 테스트,원인 효과 그래프 테스트,비교 테스트
```
|테스트 방법|설명|테스트 목적|
|------|---|---|
|구조 기반|업무 단위별 제어 흐름과 조건 결정에 따른 결과를 테스트하는 데 목적이 있다. 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트가 속한다.|제어 흐름, 조건 결정|
|명세 기반|동등 분할과 경계값 분석을 위하여 사용자의 입력, 출력, 내부 이벤트 등을 확인하는 데 목적이 있음. 목적 및 실행 코드 기반의 실행을 통한 블랙박스 테스트가 속함.|동등 분할, 경계값 분석|
# 통합 테스트
- 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 **상호작용을 테스트**한다.
- 하나의 프로세스가 완성된 경우 부분적으로 **통합 테스트를 수행하는 경우**도 있다.
- 일반적으로 빅뱅 방식보다는 **순차적 형태와 아키텍처에 대한 이해를 바탕**으로 진행된다
- 빅뱅,상향식,하향식,샌드위치,Central,Collaboration,레이어 통합 등의 테스트가 있다.
```
드라이버:상향식 테스트 방식의 존재하지 않는 상위 모듈 간의 인터페이스 역할
스텁: 하향식 테스트 방식의 작성이 쉬운 시험용 모듈
```
|구분|빅뱅|상향식|하향식|
|---|----|-----|-----|
|수행방법|모든 모듈을 동시 통합 후 수행|최하위 모듈부터 점진적으로 상위 모듈과 함께 수행|최상위 모듈부터 하위 모듈들을 통합하여 수행|
|더미 모듈|X|드라이버 필요|스텁 필요|
|장점|단시간 테스트 가능,작은 시스템에 유리|장애 위치 파악 쉬움,모듈 개발 시간 낭비가 없음|장애 위치 파악 쉬움,이른 프로토타입 가능,중요 모듈의 선 테스트 기능,결함 조기 발견 기능|
|단점|장애 위치 파악 어려움,모든 모듈 개발|이른 프로토타입 어려움,중요 모듈이 마지막으로 테스트될 가능성 높음|많은 스텁 필요,하위 모듈들의 불충분한 테스트 수행|
# 시스템 테스트
- 통합된 단위 시스템의 기능이 시스템에서 **정상적으로 수행되는지를 테스트**하는 것으로, 성능 및 장애 테스트가 여기에 포함
- 시스템 테스트는 개발 프로젝트 차원에서 정의된 **전체 시스템의 동작과 관련**된다
- 환경 제한적 장애 관련 리스크를 최소화하기 위하여 실제의 최종 사용자 환경과 유사하게 **시스템 성능,관련된 고객의 기능/비기능적인 요구사항** 등이 완벽하게 수행되는지를 테스트한다.
- 요구사항 명세서, 비즈니스 절차,유스케이스,리스크 분석 결과 등을 이용한다.
유스케이스
```
시스템의 동작을 사용자의 입장에서 표현한 시나리오  
시스템에 관련한 요구사항을 알아내는 과정
```
- 업무 기반의 **기능적 요구사항**과 시스템적인 **비기능적 요구사항**으로 나누어진다.
```
기능적 요구사항:요구사항 명세서,비즈니스 절차,유스케이스 등 명세서 기반의 블랙박스 테스트  
비기능적 요구사항:성능 테스트,회복 테스트,보안 테스트,내부 시스템의 메뉴 구조 웹 페이지의 네비게이션 등의 구조적요소에 대한 화이트박스 테스트
```
# 인수 테스트
- 일반적으로 최종 사용자와 업무에 따른 이해관계자 등이 테스트를 수행함으로써 개발된 제품에 대해 **운영 여부를 결정**하는 테스트로, **실제 업무 적용 전에 수행**
- 시스템의 일부 또는 **특정한 비기능적인 특성**을 확인
- 방법
```
사용자 인수 테스트:비즈니스 사용자가 시스템 사용의 적절성 여부 확인  
운영상의 인수 테스트:시스템 관리자가 시스템 인수 시 수행하는 테스트 활동으로 백업/복원 시스템,재난 복구, 사용자 관리,정기 점검 등을 확인  
계약 인수 테스트:계약상의 인수/검수 조건을 준수하는지 확인  
규정 인수 테스트:정부 지침,법규,규정 등 규정에 맞게 개발하였는지 확인  
알파 테스트:개발하는 조직 내 잠재 고객에 의해 테스트 수행  
베타 테스트:실제 환경에서 고객에 의해 테스트 수행
```
# 테스트 케이스
- **명세 기반 테스트의 산출물**이다
- 특정한 프로그램의 일부분 또는 **경로에 따라 수행**하거나, **특정한 요구사항을 준수**하는지 확인하기 위해 설계된 입력값, 실행 조건,기대 결과로 구성된 **테스트 항목의 명세서**를 말한다
- 미리 설계하여 오류를 방지할 수 있고 테스트 수행에 필여한 **인력, 시간 등의 낭비를 축소**할 수 있다.
- 테스트 케이스 작성 절차  
`
계획 검토 및 참조 문서 수집 → 내부 검토 및 우선순위 결정 → 요구사항 정의 → 테스트 설계와 방법 결정 → 테스트 케이스 정의 → 테스트 케이스 타당성 확인 및 유지보수 → 테스트 수행
`
# 테스트 오라클
- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 **사전에 정의된 참 값을 입력하여 비교**하는 기법 및 활동
- 테스트 오라클 유형  
```
참 오라클 : 모든 입력값의 기대 결과를 생성해서 발생된 오류를 모두 검출  
샘플링 오라클 : 특정한 입력값들에 대해서만 기대하는 결과 제공  
휴리스틱(추정) 오라클 : 샘플링 오라클을 개선한 오라클이며, 특정 입력값에 대해 올바른 결과를 제공하고 나머지 값들에 대해서는 휴리스틱(추정)으로 처리  
일관성 검사 오라클 : 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인
```
# 테스트 자동화
## 배경
소프트웨어 테스트는 소프트웨어 개발에 소요되는 총 시간과 비용의 절반 이상을 차지할 정도로 **많은  
자원이 투입** 되는 프로세스이다. 따라서 테스트의 정확성을 유지하면서 시간과 비용을 줄일 수 있는 **자동화 도구가 매우 중요**하게 되었다.
## 테스트 자동화
### 개념
- 테스트 자동화란, 사람이 하던 반복적 테스트 절차를 자동화 도구를 활용하여 테스트하는 것이다.
- 준비,구현,수행,분석 등을 스크립트 형태로 구현함으로써 테스트 시간과 인력 투입의 부담을 최소화 할 수 있고,휴먼에러를 줄일 수 있다.
- 운영 중인 시스템의 모니터링 또는 UI가 없는 서비스의 경우에도 정밀한 테스트가 가능하다.  
`
휴면에러란, 인간의 실수로 발생하는 에러
`
### 테스트 도구의 장점
- 테스트 데이터의 **재입력과 재구성 같은 반복 작업의 자동화**를 통하여 테스트 인력과 시간을 최소화한다
- 향샹된 **요구사항 정의, 성능 및 스트레스 테스트,품질 측정을 최적화** 한다.
- 빌드 확인, 회귀, 다중 플랫폼 호환성, 소프트웨어 구성, 기본 테스트 등의 **향상된 테스트 품질**을 보장한다.
### 테스트 도구의 단점
- 도입 후 **테스트 도구 전문가 양성 또는 고용**이 필요
- 초기에 프로세스 적용에 대한 **시간, 비용, 노력에 대한 추가 투자**가 필요하다.
- 비공개 상용 소프트웨어의 경우, **고가이며 인력과 교육에 대한 유지관리 비용**이 높음
### 테스트 자동화 수행 시 고려사항
- 테스트 절차를 고려하여 **재사용 및 측정이 불가능한 테스트 프로그램은 제외**해야 한다.
- 설계 기준을 고려하여 반복적인 빌드에서 **스크립트 재사용성이 가능**해야 한다.
- 도구의 한계성으로 모든 수동 테스트 과정을 자동화 할 수 있는 도구는 없으므로, **용도에 맞는 적절한 도구 사용**이 필요
- 도구 환경 설정과 도구 습득 기간을 고려하여 **프로젝트의 지연을 방지** 해야한다
- 테스트 엔지니어의 늦은 투입은 프로젝트의 이해 부족으로 불완전한 테스트를 초래할 수 있기 때문에, **프로젝트 초기에 적절한 투입 시기와 계획을 수립**해야 한다.
### 테스트 도구의 평가 방법 및 요소
|테스트 활동|테스트 도구|내용|
|----------|----------|---|
|테스트 계획|요구사항 관리|고객 요구사항 정의 및 변경 사항 관리|
|테스트 분석 설계|테스트 케이스 생성|테스트 기법에 따른 테스트 데이터 및 케이스 작성|
|``|커버리지 분석|대상 시스템에 대한 테스트 완료 범위의 척도|
|테스트 수행|테스트 자동화|기능 테스트 등 테스트 도구를 활용하여 자동화를 통한 테스트의 효율석 제고|
|``|정적 분석|코딩 표준, 런타임 오류 등을 검증|
|``|동적 분석|대상 시스템 시뮬레이션을 통한 오류 검출|
|``|성능 테스트|가상 사용자를 인위적으로 생성하여 시스템 처리 능력 측정|
|``|모니터링|시스템 자원의 상태 확인 및 분석 지원 도구|
|테스트 통제|향상 관리|테스트 수행에 필요한 다양한 도구 및 데이터 관리|
|``|테스트 관리|전반적인 테스트 계획 및 활동에 대한 관리|
|``|결함 추적/관리|테스트에서 발생한 결함 관리 및 협업 지원|
# 애플리케이션 결함 조치
## 결함의 정의
- 결함은 프로그램과 명세서 간의 차이,업무 내용의 불일치
- 결함은 기대 결과와 실제 관찰 결과 간의 차이
- 사용자가 기대하는 타당한 기대치를 시스템이 만족시키지 못할 때 변경이 필요한 모든 것을 결함
## 결함 관리 프로세스
결함 관리 계획 -> [결함 기록 -> 결함 검토 -> 결함 수정 -> 결함 재확인] -> 최종 결함 분석 및 보고서 작성  
                                    결함 관리 DB
1. 결함 관리 계획 : 전체 프로세스에서 결함 관리에 대한 일정,인력,업무 프로세스를 확보하여 계획수립
2. 결함 기록 : 테스터는 발견된 결함에 대한 정보를 결함 관리 DB에 기록
3. 결함 검토 : 등록된 결함에 있어서 주요 내용을 검토하고, 결함을 수정할 개발자에게 전달한다.
4. 결함 수정 : 개발자는 할당된 결함의 프로그램을 수정
5. 결함 재확인 : 테스터는 개발자가 수정한 내용을 확인하고 다시 테스트를 수행
6. 결함 상태 추적 및 모니터링 활동 : 결함 관리 팀장은 결함 관리 데이터베이스를 이용하여 데시보드 또는 게시판 형태의 서비스를 제공
7. 최종 결함 분석 및 보고서 작성 : 발견된 결함에 대한 내용과 이해관계자들의 의견이 반영된 보고서를 작성하고 결함 관리를 종료
## 결함의 상태 및 추적
1. 결함 등록(Open) : 테스터와 품질 관리(QA) 담당자에 의해 결함이 처음 발견되어 등록되었지만, 아직 분석되지 않은 상태
2. 결함 검토(Reviewed) : 등록된 결함을 담당 모듈 개발자, 테스터, 프로그램 리더, 품질 관리(QA) 담당자와 검토하는 단계
3. 결함 할당(Assigned) : 결함의 영향 분석 및 수정을 위해 개발자와 문제 해결 담당자에게 할당된 상태
4. 결함 수정(Resolved) : 개발자에 의해 결함이 수정 완료된 상태
5. 결함 조치 보류(Deferred) : 수정이 필요한 결함이지만 현재 수정이 불가능해서 연기된 상태, 우선순위, 일정등을 고려하여 재오픈 대기 상태
6. 결함 종료(Closed) : 발견된 결함이 해결되고 테스터와 품질 관리(QA) 담당자에 의해 종료 승인을 한 상태
7. 결함 해제(Clarified) : 테스터,프로그램 리더,품질 관리(QA) 담당자가 결함을 검토한 결과, 결함이 아니라고 판명
## 결함 분류
- 결함은 여러 가지 유형으로 나뉘며, 결함을 분석한느 단계에서 이러한 유형을 나눈다
- 시스템 결함, 기능 결함, GUI 결함,문서 결함 등 크게 4가지
### 시스템 결함
비정상적인 종료/중단, 응답시간 지연, DB에러 등 주로 애플리케이션 환경과 DB처리에서 발생하는 오류  
  
- **비정상족인 종료/중단** : 특정 기능 실행 시 응용 프로그램의 작동 정지, 종료 시스템 다운이 되는 경우  
- **응답 시간 지연** : 응용 프로그램 작동 후 조회 또는 보고서 출력 시 지연되는 경우와 메모리 부족, 하드웨어와 소프트웨어의 비일관성으로 발생되는 경우이다.   
- **데이터베이스 에러** : 응용 프로그램 작동 후 사용자 데이터의 등록, 수정, 삭제, 조회가 정상적으로 작동하지 않는 경우이다.  
### 기능 결함
사용자의 요구사할 미반영/불일치, 부정확한 비즈니스 프로세스, 스크립트 에러,타 시스템 연동 시 오류 등 기획,설계, 업무 시나리오 단계에서 발생된 결함을 말한다
- **요구사항 미반영/불일치** : 요구사항에 명시된 기능이 응용 프로그램에 구현되지 않은 경우와 다르게 구현되어 작동하는 경우이다
- **부정확한 비즈니스 프로세스** : 기능 자체는 수행되나 내부 프로세스 로직의 문제로 부정확한 결과를 내는 경우
- **스크립트 에러** : 특정 기능 실행 시 웹 브라우저에서 스크립트 오류가발생하는 경우
- **타 시스템 연동 시 오류** : 기존 시스템과의 연동을 통해 데이터를 주고받는 과정에서 오류가 발생하는 경우
### GUI 결함
GUI 결함은 응용 프로그램의 UI 비일관성, 부정확한 커서/메시지, 데이터 타입의 표시 오류 등으로 사용자 화면 설계에서 발생된 결함
- **응용 프로그램의 UI 비일관성** : 프로젝트에서 정의한 UI 표준과 상이하게 구현된 경우
- **부정확한 커서/메시지** : 커서의 위치가 입력 대상의 첫 번째 필드에 위치해 있지 않거나, 탭 시퀀스가 순차적으로 동작하지 않는 경우, 각 기능에서 제공하는 메시지 내용이 부정확한 내용을 보여주는 경우
- **데이터 타입의 표시 오류** : 입력 필드에 지정된 형식과 다르게 입력해도 저장되는 걍우와 입력 필드에 유효하지 않은 데이터를 입력했을때 오류가 나는 경우
### 문서 결함
- 기획자,사용자,개발자 간의 의사소통과 기록이 원할하지 않은 경우에 발생하는 결함이다
- 사용자의 온라인/오프라인 매뉴얼의 불일치,요구사할 분석서와 기능 요구사항 불일치로 인한 불 완전한 상태의 문서로 발생한 결함
## 결함 심각도
- 결함 심각도는 여려 개의 결함 중 전체 시스템에 결함이 미치는 영향을 레벨별로 나타낸다
- 우선순위는 High,Medium,Low로 정함
### High
- 시스템이 중단(다운)되어 더 이상 프로세스를 진행할 수 없게 만드는 결함
- 시스템의 핵심 요구사항 미구현, 시스템 구현, 시스템 다운, 장시간 시스템 응답 지연, 시스템 복구 후 데이터 왜곡 등을 말한다
### Medium
- 시스템의 흐름에 영향을 미치는 결함
- 부정확한 기능, 부정확한 업무 프로세스, 데이터 필드 형식의 오류, 데이터베이스 에러, 보안 관련 오류 등을 말한다
### Low
- 시스템의 흐름에 영향을 미치지 않지만 상황에 맞지 않는 용도와 화면 구성등의 결함
- 부정확한 GUI 및 메시지, 에러 시 메시지 미출력, 화면상의 문법/철자 오류 등을 말한다.
## 단위 테스트 기법