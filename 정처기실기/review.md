# 알고리즘
프로그램의 구성요소,문제에 답을 찾아내는 방법
## 정의
프로그램작성 과정 중 설계/계획에 포함, 문제 해결을 위한 일련의 절차나 방법을 공식화한 형태 또는 계산을 실행하기 위한 단계적 절차
## 5가지 특성
1. 입력:입력되는 값은 **0개 이상**이어야 한다.
2. 출력: 출력되는 결과가 **1개 이상**이어야 한다.
3. 명확성: 각 명령어의 **의미가 명확**해야 한다.
4. 유한성: 정해진 단계를 지나면 **종료되어야** 한다.
5. 유효성: 모든 명령을 **실행가능한 연산**이어야 한다.
# 순서도
알고리즘을 표현하는 방식 중 하나
## 순서도 연산
(>크다 ,>= 크거나 같다,< 작다,<= 작거나 같다,=같다,<>,!= 같지 않다)
## 순서도의 기호 공식
### 변수와 상수
변수: **고정되어 있지 않은 값** 또는 어떤 값을 주기억장치에 기억하기 위해 사용하는 **공간**  
상수: **고정되어 있는 값**,이미 지정되어 있는 **불변의 값**
# 프로그래밍 언어
## 개요
프로그래밍 언어란 컴퓨터 시스템을 동작시키기 위한 **프로그램 작성언어**를 말한다  
프로그램은 다소 단순해 보이는 명령어 들의 조합으로 구성되는데, 이러한 조합들을 비트라고 불리는 0과1의 값으로 작성되거나 변환되어 **컴퓨터가 이해할 수 있도록** 한다 
## Bit
컴퓨터가 이해하기 위한 가장 기본적인 용어로,BinaryDigit의 약칭
1Byte == 8bit, 1kilobyte == 8192bit,이후는 2^10씩 byte가 늘어난다
## 컴퓨터 시스템의 구조
컴퓨터는 전달받은 0과 1의 값들을 정해진 순서대로 실행하며 그 과정에서 처리,저장등을 수행,**프로그램 실행 및 데이터 처리는 중앙처리장치(CPU)에서 수행,저장은 기억장치(Memory)에서 수행 cpu로 부터 명령받아 데이터를 입력 또는 출력하는 일을 입출력 장치(1/0 device)에서 수행 cpu에서는 목적에 따라 연산 등을 수행**, 연산을 위한 명령어를 실행,기록 하기 위해서는 일반적으로 **인출,해석,실행,기록**의 단계를 거쳐야 한다.
## 기본 용어
변수:어떤 값을 주기억장치에 기억하기 위해서 사용하는 **공간**
## 식별자
프로그램의 **구성요소를 구별하기 위한 기준**으로,변수명이 식별자에 속함
## 바인딩
변수가 변수에 관련된 속성을 연결하는 과정,정적,동적 바인딩으로 구분  
- 정적: 프로그램 **실행시간 전에** 속성을 연결하는 방식
- 동적: 프로그램 **실행시간에** 속성을 연셜하는 방식
## 선언
변수에 이름,데이터 타입 등의 **속성을 수여하는 작업**으로,명시적 선언과 묵시적 선언이 있다  
- 명시적: **선언문을 이용**하여 변수 이름을 나열하고 속성을 부여
- 묵시적: 별도의 **선언문 없이** 디폴트 규칙에 의해 속성을 부여
## 영역
이름이 사용되는 범위를 의미,정적,동적으로 나뉨  
- 정적: 변수를 찾을때 **구조에 기반**
- 동적: 변수를 찾을때 구조보다 **순서에 기반**
## 할당
변수에 **메모리공간을 바인딩** 하는 작업을 의미
## 변수
저장하고자 하는 어떤 값이 있을 때,그 값을 **주기적장치에 기억하기 위한 공간**
## 서식지정자
%d 정수(부호O)/ %y 정수(부호X) / %o 8진수 정수(부호X) / %x 16진수 정수(부호X) / %f 소수점 6번째 자리까지의 실수 / %e 실수 / %g 크기에 따라 면하는 실수 / %c 문자 / %s 문자열
# 연산자
## 시프트 연산자
10진수 값을 2진수로 변환하여 **비트의 위치를 이동**시키는 연산자이다.  
5 << 2 = (0000 0101 -> 00010100) = 20
## 비트 연산자
&(and) 2진수 값이 1이면 1 / |(or) 2진수 값중 하나라도 1이면 1
# 자료형
## 사용자 정의 자료형
C/C++ , JAVA 와 같은 언어는 직접 **자료형을 만들수 있음**
### 열거체
괄호 안에 **연속적인 값이 들어가는 자료형**,특정 값을 넣어주지 않으면 **1씩늘어난다** 상수배열이라고 불림
```java
enum{
    black;
    red;
    yellow = 10;
    green;
};//여기서 black = 0,red = 1(0에서 1증가),yellow=10,green=11(10에서 1증가)
```
### 구조체
괄호안에 **멤버 변수를 사용하는 자료형**,내부에서 멤버 변수 자료형 선언 가능,멤버 함수 작성 가능
```java
struct test//여기서 test는 이름
{
int kor;
int eng;
int mat;
};
main()
{
    struct test t1;
    t1.kor = 90;
    t1.eng = 80;
    t1.mat = 100;
};
```
### 공용체
- 구조체와 비슷하지만 **조금더 범위가 크다** 
- 열거체와 구조체와 달리 **공용체명 작성 필요**
- **구조체를 멤버**로 사용가능
- 메모리 공간을 공유해 **크기를 작게** 사용가능
## 추상화
복잡한 문제의 본질을 이해하기 위해 세부사항은 배제하고 **중요한 부분을 중심으로 간략화**하는 기법
### 기능
입력자료를 출력자료로 **변환하는 과정을 추상화** 하는 방법
### 자료
**자료**와 자료에 적용할수있는 **오퍼레이션**을 **함께 정의**하는 방법(오퍼레이션은 추상화 할수 있게 해주는 것이다)
### 제어
**외부 이벤트**에 대한 **반응**을 **추상화** 하는 방법
## 상속
상위 수준 그룹의 **모든 특성**을 하위 수준 그룹이 이어받아 **재사용,확장** 하는 특성  
단위상속과 다중상속이 있고,상위수준의 그룹의 그룹이 하나만 존재할때 단일상속이라고 부름
## 구체화
하위 수준 그룹이 상위 수준 그룹의 **추상화 부분을 구체화** 시키는 것을 의미
# 프로그래밍 언어 특성
## 발전과정
|1960년 이전|1960년대|1970년대|1980년대|1980년 이후|
|----------|-------|---------|-------|----------|
|ASSEMBLY,FORTRAN,LISP|COBOL,PL/I,BASIC|PASCAL,C,SMALLTALK,PROLOG|ADA,C++,PYTHON,PROLOG|RUBY,JAVA,JAVASCRIPT,C#|
## 유형 분류
- 저급언어: **기계가** 이해하도록 만들어진 언어. 추상화 수준이 낮고,프로그램작성이 어려움, 기계어 어셈블리어가 속함
- 고급언어: **개발자가** 소스코드를 작성할때 쉽게 이해할 수 있도록 작성된언어 C,C++,JAVA등이 속함
### 실행 방식
- **명령형 언어**: 컴퓨터에 저장된 명령어들이 효과적으로 실행되는 프로그래밍 방식으로 **절차형 언어**
- **함수형 언어**: **수학적 수식과 같은 함수**들로 프로그램을 구상하여 호출하는 방식
- **논리형 언어**: **규칙**에 대한 활성화 **조건이 만족**되면 **연관된 규칙이 실행**되는구조,**추론과 관계 규칙**에 의해 원하는 결과를 얻음
- **객체지향 언어**: **객체간의 메세지 통신**을 이용하여 프로그래밍 하는 방식
### 구현기법
- **컴파일 방식의 언어**: **고급언어를 기계어로 번역하는 방식**의 언어를 의미. 컴파일 방식은 실행에 필여한 정보가 **컴파일시간에 계산**되어 실행 속도가 높음
- **인터프리터 방식의 언어**: 고급언어 **명령문을 하나씩 번역**하고 실행하는 방식의 언어 **프로그램실행시 계산**시작
- **혼합형 방식의 언어**: 고급 언어를 **컴파일**하여 **중간언어로 변환**후 **인터프리터**에 의해 번역을 실행
# 라이브러리
## 정의
효율적인 프로그램 개발을 위해 필요한 프로그램을 모아놓은 **집합체**  
필요할 때 찾아서 쓸수있도록 **모듈화** 되어 제공  
프로그래밍 언어에 일반적으로 **도움말,설치 파일,샘플 모드** 등을 제공
## 종류
### 표준 라이브러리
- 표준 라이브러리는 프로그래밍 언어가 **기본적으로 가지고** 있는 라이브러리를 의미가
- 각 프로그래밍 언어의 표준 라이브러리는 **여러 종류의 모듈과 패키지**를 가짐
- 표준 라이브러리를 이용하면 별도의 파일 설치없이 날짜와 시간기능을 이용가능
### 외부 라이브러리
- 외부라이브러리는 표준라이브러리와 달리 별도의 파일을 설치
- 누구나 개발,설치 가능,인터넷에 공유가능
### 모듈과 패키지
- 라이브러리는 모듈과 패키지를 총칭한다
- 개별 파일은 모듈,모듈을 모은것은 패키지 라고 한다
```
모듈:특정 기능들(변수,함수,클래스 등)이 한 개의 파일에서 기능을 제공한다  
패키지:여러 개의 모듈을 한 개의 폴더에 묶어서 기능을 제공
```
# 테스트
## 개요
- 테스트란, 개발된 응용 애플리케이션이나 시스템의 사용자가 요구하는 기능과 성능,사용성,안전성등을 확인하고 **노출되지 않은 숨어있는 결함을 찾아내는 활동**
- 테스트 과정에 필요한 역할은 **소프트웨어 아키텍트**와 **테스트 매니저**이다  
그림과 같이 두 역할은 소프트웨어 생명 주기(Life Cycle)의 V 모델에서 각각 좌측과 우측의핵심 역할을 담당하고 **서로 보완 관계**에 있다  
소프트웨어 생명 주기는 요구사할,분석,디자인,구현 또는 개발 순으로 진행되며, 프로젝트의 특성과 방법론에 따라 반복적으로 수행되기도 한다.  
테스트는 단위 테스트,통합 테스트,시스템 테스트,인수 테스트의 순으로 진행  
요구사항 -> 분석-시스템 설계 -> 디자인-모듈 설계 -> 구현-코딩 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
## 테스트의 7 원칙
1. 테스트는 **계획 단계부터** 한다
- 테스트 활동은 소프트웨어 개발 주기에서 가능한 초기부터 시작해야 한다.
2. 테스트는 **결함을 밝히**는 활동이다.
- 테스트의 목적은 결함의 제거가 아닌, 결함의 발견이다
- 테스트는 결함이 있다는 것을 보여줄 수 있지만, 결함이 없다는 것을 증명할 수는 없다
3. **완전한 테스트는 불가능**하다
- 모든 것(입력값,결로,타이밍)에 대한 테스팅은 자원의 한계로 불가능하다
4. 테스트는 **상황에 따라 다르다**
- 애플리케이션 테스트에서도 동일한 테스트에 대한 비정상적인 결함 검수가 이루어질 수 있으므로, 이러한 현상을 방지하기 위해서는 다양한 방법으로 테스트하는 것이 필요하다
5. **결함 집중을 고려**한다.
- 대부분 결함은 소수의 특정 모듈에 집중되어 발생하는 경향을 보인다.
- 결함의 80%는 20% 코드에 집중되어 있다. 즉, 결함이 높은 곳에 자원이 집중되어 있다(파레토 법칙)
6. **살충제 패러독스를 고려**한다.
- 동일한 테스트 케이스에 의한 반복적 테스트로 새로운 버그를 찾지 못하는 내성 현상을 의미
7. **오류 부재의 궤변을 고려**
- 개발한 제품이 사용자의 필요와 기대에 부응하지 못하고 쓸모가 없다면 결함을 찾는 활동은 의미가 없다.
- 개발한 제품은 요구 사항과 일치하고 사용에 적합해야 한다.
# 단위 테스트
- **작은 소프트웨어 단위**(컴포넌트 또는 모듈)를 **테스트** 하는 것으로, 일반적으로 개발자 자신에 의해 진행
- 과거에는 시간 부족을 이유로 단위 테스트가 생략되었으나 최근에는 개발 도구의 발전으로 **개발 과정중에 자동으로 진행**
- 단위 테스트는 아주 중요한 부분이므로 개발 도구에서 지원하지 않아도 **반드시 수행**
- 구조적 테스트,기능성 테스트,리소스 관련 테스트,강건성 테스트 등 특정 비기능성 테스트 등이 포함되어 수행
- 컴포넌트 명세,소프트웨어 상세 설계,데이터 모델 명세 등을 이용하여 테스트
- 방법  
화이트박스 테스트  
```
개발자 관점 구조와 동작 기반의 테스트
종류: 기초 경로 테스트,제어 흐름 테스트,조건 테스트,루프 테스트,데이터 흐름 테스트,분기 테스트
```
  
블랙박스 테스트  
```
사용자 관점,명세[요구사항과 결과물이 일치] 기반의 테스트  
종류:균등 분할(동치분해),한계값(경계값) 테스트,원인 효과 그래프 테스트,비교 테스트
```
|테스트 방법|설명|테스트 목적|
|------|---|---|
|구조 기반|업무 단위별 제어 흐름과 조건 결정에 따른 결과를 테스트하는 데 목적이 있다. 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트가 속한다.|제어 흐름, 조건 결정|
|명세 기반|동등 분할과 경계값 분석을 위하여 사용자의 입력, 출력, 내부 이벤트 등을 확인하는 데 목적이 있음. 목적 및 실행 코드 기반의 실행을 통한 블랙박스 테스트가 속함.|동등 분할, 경계값 분석|
# 통합 테스트
- 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 테스트한다.
- 하나의 프로세스가 완성된 경우 부분적으로 통합 테스트를 수행하는 경우도 있다.
- 일반적으로 빅뱡 방식보다는 순차적 형태와 아키텍처에 대한 이해를 바탕으로 진행된다
- 빅뱅,상향식,하향식,샌드위치,Central,Collaboration,레이어 통합 등의 테스트가 있다.
```
드라이버:상향식 테스트 방식의 존재하지 않는 상위 모듈 간의 인터페이스 역할
스텁: 하향식 테스트 방식의 작성이 쉬운 시험용 모듈
```
|구분|빅뱅|상향식|하향식|
|---|----|-----|-----|
|수행방법|모든 모듈을 동시 통합 후 수행|최하위 모듈부터 점진적으로 상위 모듈과 함께 수행|최상위 모듈부터 하위 모듈들을 통합하여 수행|
|더미 모듈|X|드라이버 필요|스텁 필요|
|장점|단시간 테스트 가능,작은 시스템에 유리|장애 위치 파악 쉬움,모듈 개발 시간 낭비가 없음|장애 위치 파악 쉬움,이른 프로토타입 가능,중요 모듈의 선 테스트 기능,결함 조기 발견 기능|
|단점|장애 위치 파악 어려움,모든 모듈 개발|이른 프로토타입 어려움,중요 모듈이 마지막으로 테스트될 가능성 높음|많은 스텁 필요,하위 모듈들의 불충분한 테스트 수행|